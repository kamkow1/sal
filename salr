#!/usr/bin/env python3

import sys
import lark
import os
import abc
import pprint
import enum
import ctypes
import copy
from llvmlite import ir
from llvmlite import binding

class Node(abc.ABC):
    def __init__(self, line, col):
        self.line = line
        self.col  = col

class Modifier_Types(enum.Enum):
    DECLARE = enum.auto()
    DEFINE  = enum.auto()

class Modifier_Node(Node):
    def __init__(self, line, col, name):
        self.line     = line
        self.col      = col
        self.modifier = Modifier_Types[name.upper()]

class Proc_Node(Node):
    def __init__(self, line, col, modifiers, name, proc_params, return_type, code_block, template):
        super().__init__(line, col)
        self.modifiers   = modifiers
        self.name        = name
        self.proc_params = proc_params
        self.return_type = return_type
        self.code_block  = code_block
        self.template    = template

class Plain_Type_Node(Node):
    def __init__(self, line, col, name):
        super().__init__(line, col)
        self.name = name

    def __str__(self):
        return self.name.text

class Proc_Params_Pair_Node(Node):
    def __init__(self, line, col, name, type_, is_va_args):
        super().__init__(line, col)
        self.name       = name
        self.type_      = type_
        self.is_va_args = is_va_args

class Identifier_Node(Node):
    def __init__(self, line, col, text):
        super().__init__(line, col)
        self.text = text

class Code_Block(Node):
    def __init__(self, line, col, statements):
        super().__init__(line, col)
        self.statements = statements

class Variable_Node(Node):
    def __init__(self, line, col, modifiers, name, type_, assign):
        super().__init__(line, col)
        self.modifiers = modifiers
        self.name      = name
        self.type_     = type_
        self.assign    = assign

class Assing_Node(Node):
    def __init__(self, line, col, value):
        super().__init__(line, col)
        self.value = value

class Reassignment_Node(Node):
    def __init__(self, line, col, name, assign):
        super().__init__(line, col)
        self.name   = name
        self.assign = assign

class Integer_Node(Node):
    def __init__(self, line, col, i):
        super().__init__(line, col)
        self.i = i

class Ptr_Type_Node(Node):
    def __init__(self, line, col, pointee):
        super().__init__(line, col)
        self.pointee = pointee

    def __str__(self):
        return "*" + str(self.pointee)

class Addr_Of_Node(Node):
    def __init__(self, line, col, pointee):
        super().__init__(line, col)
        self.pointee = pointee

class Proc_Type_Node(Node):
    def __init__(self, line, col, proc_params, return_type):
        super().__init__(line, col)
        self.proc_params = proc_params
        self.return_type = return_type

    def __str__(self):
        s = "proc("
        for i, p in enumerate(self.proc_params):
            if i != 0:
                s += ","
            s += str(p.type_)
        s += ")"
        s += str(self.return_type)
        return s

class String_Node(Node):
    def __init__(self, line, col, text):
        super().__init__(line, col)
        self.text = text

class Proc_Call_Node(Node):
    def __init__(self, line, col, callee, args, generic_args):
        super().__init__(line, col)
        self.callee       = callee
        self.args         = args
        self.generic_args = generic_args

class Template_Node(Node):
    def __init__(self, line, col, templates):
        super().__init__(line, col)
        self.templates = templates

class Type_List_Node(Node):
    def __init__(self, line, col, types):
        super().__init__(line, col)
        self.types = types

class Start_Node(Node):
    def __init__(self, line, col, statements):
        super().__init__(line, col)
        self.statements = statements

class Ast_Builder(lark.Transformer):
    def IDENTIFIER(self, item):
        return Identifier_Node(
            item.line,
            item.column,
            str(item.value)
        )

    def ESCAPED_STRING(self, item):
        text = str(item.value)
        text = text.replace("\\n", "\n")
        return String_Node(
            item.line,
            item.column,
            text
        )

    def type_list(self, items):
        return Type_List_Node(
            items[0].line,
            items[0].col,
            items
        )

    def proc_call(self, items):
        if isinstance(items[0], Type_List_Node):
            return Proc_Call_Node(
                items[0].line,
                items[0].col,
                items[1],
                items[2:],
                items[0]
            )
        else:
            return Proc_Call_Node(
                items[0].line,
                items[0].col,
                items[0],
                items[1:],
                None
            )

    def proc_type(self, items):
        return Proc_Type_Node(
            items[1].line,
            items[1].col,
            items[0],
            items[1]
        )

    def addr_of(self, items):
        return Addr_Of_Node(
            items[0].line,
            items[0].col,
            items[0]
        )

    def integer(self, items):
        return Integer_Node(
            items[0].line,
            items[0].column,
            int(items[0].value)
        )

    def assign(self, items):
        return Assing_Node(
            items[0].line,
            items[0].col,
            items[0]
        )

    def reassignment(self, items):
        return Reassignment_Node(
            items[0].line,
            items[0].col,
            items[0],
            items[1]
        )

    def plain_type(self, items):
        return Plain_Type_Node(
            items[0].line,
            items[0].col,
            items[0]
        )

    def ptr_type(self, items):
        return Ptr_Type_Node(
            items[0].line,
            items[0].col,
            items[0]
        )

    def variable(self, items):
        modifiers = []
        for item in items:
            if isinstance(item, Modifier_Node):
                modifiers.append(item)
        name = items[len(modifiers):][0]
        type_ = items[len(modifiers)+1:][0]
        assign = items[len(modifiers)+2:][0] if len(items[len(modifiers)+2:]) > 0 else None
        return Variable_Node(
            items[0].line,
            items[0].col,
            modifiers,
            name,
            type_,
            assign
        )

    def code_block(self, items):
        if len(items) > 0:
            return Code_Block(
                items[0].line,
                items[0].col,
                items
            )
        else:
            return Code_Block(
                -1,
                -1,
                items
            )

    def proc_params_pair(self, items):
        if str(items[0]) == "...":
            return Proc_Params_Pair_Node(
                items[0].line,
                items[0].column,
                None,
                None,
                True
            )
        else:
            name = items[0]
            type_ = items[1]
            return Proc_Params_Pair_Node(
                items[0].line,
                items[0].col,
                name,
                type_,
                False
            )

    def proc_params(self, items):
        return items

    def modifier(self, items):
        return Modifier_Node(
            items[0].line,
            items[0].column,
            items[0]
        )
    
    def template(self, items):
        return Template_Node(
            items[0].line,
            items[0].col,
            items
        )

    def proc(self, items):
        offset = 0

        template = None
        if isinstance(items[0], Template_Node):
            template = items[0]
            offset += 1

        modifiers = []
        for item in items:
            if isinstance(item, Modifier_Node):
                modifiers.append(item)
        offset += len(modifiers)

        name = items[offset:][0]
        proc_params = items[offset+1:][0]
        return_type = items[offset+2:][0]
        code_block = items[offset+3:][0] if len(items[offset+3:]) > 0 else None

        return Proc_Node(
            items[0].line,
            items[0].col,
            modifiers,
            name,
            proc_params,
            return_type,
            code_block,
            template,
        )

    def start(self, items):
        return Start_Node(
            items[0].line,
            items[0].col,
            items
        )

def is_void_type(t):
    return type(t).__name__ == "VoidType"

class Stack_Frame:
    def __init__(self):
        self.values = {}
        self.generics = {}

class Proc:
    def __init__(self, compiler, node, llvm_func, params):
        self.compiler     = compiler
        self.node         = node
        self.llvm_func    = llvm_func
        self.params       = params
        self.returned     = False

    def prologue(self):
        prologue = self.llvm_func.append_basic_block("prologue")
        self.compiler.builder = ir.IRBuilder(prologue)

        for i, p in enumerate(self.params):
            self.compiler.stack_frames[-1].values[p[0]] = self.compiler.builder.alloca(p[1], name=p[0])
            self.compiler.builder.store(self.llvm_func.args[i], self.compiler.stack_frames[-1].values[p[0]])

    def epilogue(self):
        if not self.returned:
            if is_void_type(self.llvm_func.function_type.return_type):
                self.compiler.builder.position_at_end(self.compiler.builder.block)
                self.compiler.builder.ret_void()
            else:
                self.compiler.error(self.compiler.source_path + ":" + str(self.node.line) + ":" + str(self.node.col)
                            + ": return statement is missing for " + self.llvm_func.name + ".")

class Variable:
    def __init__(self, llvm_var):
        self.llvm_var = llvm_var

string_counter = 0

def string_name():
    sc = string_counter
    string_counter += 1
    return str(sc)

class Compiler:
    def __init__(self, source_path, ast):
        self.ok = True
        self.source_path = source_path
        self.ast = ast
        self.ast_visitors = {
            "Start_Node":            self.visit_start_node,
            "Proc_Node":             self.visit_proc_node,
            "Plain_Type_Node":       self.visit_plain_type_node,
            "Proc_Params_Pair_Node": self.visit_proc_params_pair_node,
            "Variable_Node":         self.visit_variable_node,
            "Integer_Node":          self.visit_integer_node,
            "Reassignment_Node":     self.visit_reassignment_node,
            "Ptr_Type_Node":         self.visit_ptr_type_node,
            "Addr_Of_Node":          self.visit_addr_of_node,
            "Identifier_Node":       self.visit_identifier_node,
            "Proc_Type_Node":        self.visit_proc_type_node,
            "String_Node":           self.visit_string_node,
            "Proc_Call_Node":        self.visit_proc_call_node,
        }

        self.stack_frames = []
        self.stack_frames.append(Stack_Frame())

        self.types_map = {
            "void":  ir.VoidType(),
            "int":   ir.IntType(32),
            "int32": ir.IntType(32),
            "int8":  ir.IntType(8),
        }

        pre, ext = os.path.splitext(source_path)
        self.out = pre + ".ll"
        self.module = ir.Module(self.out)
        self.module.triple = binding.get_default_triple()
        self.builder = None
        self.current_variable_type = None
        self.load_current_value = True

        self.builtins = {
            "cast": self.cast,
            "make_template": self.make_template,
        }

    def error(self, msg):
        print(msg)
        self.ok = False

    def declared(self, node):
        for m in node.modifiers:
            if m.modifier == Modifier_Types.DECLARE:
                return True
        return False
    
    def defined(self, node):
        for m in node.modifiers:
            if m.modifier == Modifier_Types.DEFINE:
                return True
        return False

    def name_available(self, name):
        for sf in self.stack_frames:
            if name in sf.values:
                return False
        return True

    def find_value(self, name):
        for sf in self.stack_frames:
            if name in sf.values:
                return sf.values[name]
        return None
    
    def find_generic(self, name):
        for sf in self.stack_frames:
            if name in sf.generics:
                return sf.generics[name]
        return None

    def populate_template_type(self, type_, templates, types):
        if isinstance(type_, Plain_Type_Node):
            name = type_.name.text
            if name[0] == "$":
                real_name = name[1:]
                for i, template in enumerate(templates):
                    if real_name == template:
                        return (types[i], True)
        elif isinstance(type_, Ptr_Type_Node):
            type_.pointee, changed = self.populate_template_type(type_.pointee, templates, types)
            return (type_, changed)
        elif isinstance(type_, Proc_Type_Node):
            t = type_
            t.return_type, changed = self.populate_template_type(t.return_type, templates, types)
            for p in t.proc_params:
                p.type_, changed = self.populate_template_type(p.type_, templates, types)
            return (t, changed)
        return (type_, False)

    def make_template(self, node, args):
        if len(args) < 2:
            self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                    + ": make_template(`template item`, type `type`, ...) requires 2 or more arguments.")


        if not isinstance(args[0], Identifier_Node):
            self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                    + ": make_template first argument must be an identifier.")

        types = args[1:]
        name = args[0].text
        g = copy.deepcopy(self.find_generic(name))
        if g is None:
            self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                    + ": Item " + name + " doesn't exist.")

        templates = [t.text for t in g.template.templates]

        if len(templates) != len(types):
            self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                    + ": " + str(len(templates)) + " parameters for template, but " + str(len(types)) + " were given")

        populated_templates = []

        g.return_type, changed = self.populate_template_type(g.return_type, templates, types)
        if changed:
            populated_templates.append(g.return_type)

        for param in g.proc_params:
            param.type_, changed = self.populate_template_type(param.type_, templates, types)
            if changed:
                populated_templates.append(param.type_)

        for pt in populated_templates:
            g.name.text += "@@" + str(pt)
        g.template = None

        self.visit_proc_node(g)

    def cast(self, node, args):
        if len(self.stack_frames) == 1:
            self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                    + ": cast() can only be used within a context of a procedure.")

        if len(args) != 2:
            self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                       + ": cast(type `target`, `value`) requires 2 arguments.")

        target = self.visit(args[0])
        value = self.visit(args[1])

        if isinstance(value.type, ir.PointerType) and isinstance(target, ir.PointerType):
            return self.builder.bitcast(value, target)
        else:
            self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                    + ": unsupported cast type.")
        return None

    def visit_proc_call_node(self, node):
        callee = None
        if isinstance(node.callee, Identifier_Node):
            name = node.callee.text
            if name in self.builtins:
                return self.builtins[name](node, node.args)
            else:
                if len(self.stack_frames) == 1:
                    self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                            + ": calls can only be used within a context of a procedure.")

                g = copy.deepcopy(self.find_generic(name))
                if node.generic_args is not None and g is not None:
                    templates = [t.text for t in g.template.templates]

                    if len(templates) != len(node.generic_args.types):
                        self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                                + ": " + str(len(templates)) + " parameters for template, but " + str(len(types)) + " were given")
                    populated_templates = []

                    g.return_type, changed = self.populate_template_type(g.return_type, templates, node.generic_args.types)
                    if changed:
                        populated_templates.append(g.return_type)

                    for param in g.proc_params:
                        param.type_, changed = self.populate_template_type(param.type_, templates, node.generic_args.types)
                        if changed:
                            populated_templates.append(param.type_)

                    for pt in populated_templates:
                        g.name.text += "@@" + str(pt)
                    name = g.name.text

                v = self.find_value(name)

                if v is not None and isinstance(v, Proc):
                    args = [self.visit(arg) for arg in node.args]
                    return self.builder.call(v.llvm_func, args)
                else:
                    self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                            + ": Item " + name + " doesn't exist.")
        return None

    def visit_string_node(self, node):
        if len(self.stack_frames) == 1:
            self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                    + ": Strings can only be used within a context of a procedure.")

        text = node.text[1:-1] + "\0"
        const = ir.Constant(
            ir.ArrayType(ir.IntType(8), len(text)),
            bytearray(text.encode("utf8"))
        )
        alloca = self.builder.alloca(ir.ArrayType(ir.IntType(8), len(text)))
        self.builder.store(const, alloca)
        if self.load_current_value:
            return self.builder.load(alloca)
        else:
            return alloca

    def visit_proc_type_node(self, node):
        return_type = self.visit(node.return_type)
        proc_params = [self.visit(p) for p in node.proc_params]

        return ir.FunctionType(return_type, proc_params)

    def visit_identifier_node(self, node):
        name = node.text
        v = self.find_value(name)
        if v is None:
            self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                    + ": Item " + name + " doesn't exist.")
        if self.load_current_value:
            if isinstance(v, Variable):
                return self.builder.load(v.llvm_var)
            elif isinstance(v, Proc):
                return self.builder.load(v.llvm_func)
        else:
            if isinstance(v, Variable):
                return v.llvm_var
            elif isinstance(v, Proc):
                return v.llvm_func

    def visit_addr_of_node(self, node):
        self.load_current_value = False
        pointee = self.visit(node.pointee)
        self.load_current_value = True
        return pointee

    def visit_ptr_type_node(self, node):
        t = self.visit(node.pointee)
        return t.as_pointer()

    def visit_reassignment_node(self, node):
        name = node.name.text
        v = self.find_value(name)
        
        if v is None:
            self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                    + ": Item " + name + " doesn't exist.")

        if isinstance(v, Variable):
            self.current_variable_type = v.llvm_var.type.pointee
        elif isinstance(v, Proc):
            self.current_variable_type = v.llvm_func.type
        value = self.visit(node.assign.value)
        
        self.current_variable_type = None

        if isinstance(v, Variable):
            self.builder.store(value, v.llvm_var)
        elif isinstance(v, Proc):
            self.builder.store(value, v.llvm_func)

        return None

    def visit_integer_node(self, node):
        if not isinstance(self.current_variable_type, ir.IntType):
            self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                    + ": Cannot assign non-integer value to integer-type variable.")
        return ir.Constant(self.current_variable_type, node.i)

    def visit_variable_node(self, node):
        name = node.name.text
        type_ = self.visit(node.type_)

        if not self.name_available(name):
            self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                    + ": Item " + name + " is already in scope")

        if self.declared(node) and node.assign is not None:
            self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                    + ": Use define instead of declare if you'd like to assign a value.")

        if self.defined(node) and node.assign is None:
            self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                    + ": A defined variable must have a value assigned.")

        if node.assign is not None and len(self.stack_frames) == 1:
            self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                    + ": Global variables cannot be initialized in-place.")


        if len(self.stack_frames) == 1:
            self.stack_frames[-1].values[name] = Variable(ir.GlobalVariable(self.module, type_, name))
        else:
            self.stack_frames[-1].values[name] = Variable(self.builder.alloca(type_, name=name))

        if node.assign is not None:
            self.current_variable_type = type_
            val = self.visit(node.assign.value)
            self.builder.store(val, self.stack_frames[-1].values[name].llvm_var)
            self.current_variable_type = None

        return None

    def visit_start_node(self, node):
        for statement in self.ast.statements:
                self.visit(statement)
        return None

    def visit_proc_params_pair_node(self, node):
        if node.is_va_args:
            return (None, None, True)
        else:
            name = node.name.text
            type_ = self.visit(node.type_)
            return (name, type_, False)

    def visit_plain_type_node(self, node):
        name = node.name.text
        if name not in self.types_map:
            self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                    + ": Type " + name + " is not available")
        return self.types_map[name]

    def visit_proc_node(self, node):
        if node.template is not None:
            self.stack_frames[-1].generics[node.name.text] = node
        else:
            return_type = self.visit(node.return_type)
            proc_params = [self.visit(p) for p in node.proc_params]
            name = node.name.text
            
            if not self.name_available(name):
                self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                        + ": Item " + name + " is already in scope")

            if self.declared(node) and self.defined(node):
                self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                      + ": Procedure " + name + " cannot be defined and declared at the same time.")
            
            va_args = False
            if len(proc_params) > 0:
                va_args = proc_params[-1][2]
            param_types = [t[1] for t in proc_params] if not va_args else [t[1] for t in proc_params[:-1]]
            llvm_func = ir.Function(
                self.module,
                ir.FunctionType(return_type, param_types, va_args),
                name
            )
            self.stack_frames[-1].values[name] = Proc(self, node, llvm_func, proc_params)
            
            if self.defined(node) and node.code_block is None:
                self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                      + ": Procedure " + name + " is defined, but it's code block is missing.") 

            if self.defined(node):
                self.stack_frames.append(Stack_Frame())
                self.find_value(name).prologue()

                if node.code_block is not None:
                    for statement in node.code_block.statements:
                        self.visit(statement)

                self.find_value(name).epilogue()
                self.stack_frames.pop()

        return None

    def visit(self, node):
        return self.ast_visitors[type(node).__name__](node)

    def compile(self):
        self.visit(self.ast)

def process_source(source_path, source, opts):
    with open("sal.lark") as f:
        grammar = f.read()
    
    p = lark.Lark(grammar, start="start", ambiguity="explicit")
    tree = p.parse(source)
    transformed = Ast_Builder().transform(tree)
    c = Compiler(source_path, transformed)
    c.compile()
    if c.ok:
        binding.initialize()
        binding.initialize_native_target()
        binding.initialize_native_asmprinter()

        parsed = binding.parse_assembly(str(c.module))
        parsed.verify()

        if opts.print_llvm_module:
            print(str(c.module))

        target = binding.Target.from_default_triple()
        machine = target.create_target_machine()
        with binding.create_mcjit_compiler(parsed, machine) as ee:
            ee.finalize_object()
            Main_ptr = ee.get_function_address("Main")
            Main = ctypes.CFUNCTYPE(None)(Main_ptr)

            Main()

class Command:
    def __init__(self, fn, desc):
        self.fn   = fn
        self.desc = desc

class Process_Source_Options:
    def __init__(self):
        self.print_llvm_module = False

def run_command(argv):
    if len(argv) == 0:
        print("Bad arguments. Help:")
        print(commands["run"].desc)
        sys.exit(1)

    file = argv.pop(0)

    opts = Process_Source_Options()

    while len(argv) > 0:
        arg = argv.pop(0)

        if arg == "-print-llvm-module":
            opts.print_llvm_module = True

    with open(file, "r") as f:
        source = f.read()
    process_source(file, source, opts)

def help_command(argv):
    global commands

    print("Commands:\n")
    for command in commands:
        print(commands[command].desc)

commands = {
    "run": Command(
        run_command,
        (
            f"{sys.argv[0]} run <FILE> <options>\n"
            "Compile and run contetns of <FILE>\n"
        )
    ),
    "help":  Command(
        help_command,
        (
            f"{sys.argv[0]} help\n"
            "prints this help message\n"
        )
    )
}

def main():
    os.chdir(os.path.dirname(os.path.realpath(__file__)))

    argv = sys.argv

    if len(argv) < 2:
        print("No command provided")
        sys.exit(1)

    argv.pop(0)
    command = argv[0]
    if command in commands:
        argv.pop(0)
        commands[command].fn(argv)
    else:
        print(f"Unknown command '{command}'")
        sys.exit(1)

main()

