#!/usr/bin/env python3

import sys
import lark
import os
import abc
import pprint
import enum
import ctypes
from llvmlite import ir
from llvmlite import binding

class Node(abc.ABC):
    def __init__(self, line, col):
        self.line = line
        self.col  = col

class Modifier_Types(enum.Enum):
    DECLARE = enum.auto()
    DEFINE  = enum.auto()

class Modifier_Node(Node):
    def __init__(self, line, col, name):
        self.line     = line
        self.col      = col
        self.modifier = Modifier_Types[name.upper()]

class Proc_Node(Node):
    def __init__(self, line, col, modifiers, name, proc_params, return_type, code_block):
        super().__init__(line, col)
        self.modifiers   = modifiers
        self.name        = name
        self.proc_params = proc_params
        self.return_type = return_type
        self.code_block  = code_block

class Plain_Type_Node(Node):
    def __init__(self, line, col, name):
        super().__init__(line, col)
        self.name = name

class Proc_Params_Pair_Node(Node):
    def __init__(self, line, col, name, type_):
        super().__init__(line, col)
        self.name  = name
        self.type_ = type_

class Identifier_Node(Node):
    def __init__(self, line, col, text):
        super().__init__(line, col)
        self.text = text

class Code_Block(Node):
    def __init__(self, line, col, statements):
        super().__init__(line, col)
        self.statements = statements

class Variable_Node(Node):
    def __init__(self, line, col, modifiers, name, type_, assign):
        super().__init__(line, col)
        self.modifiers = modifiers
        self.name      = name
        self.type_     = type_
        self.assign    = assign

class Assing_Node(Node):
    def __init__(self, line, col, value):
        super().__init__(line, col)
        self.value = value

class Reassignment_Node(Node):
    def __init__(self, line, col, name, assign):
        super().__init__(line, col)
        self.name   = name
        self.assign = assign

class Integer_Node(Node):
    def __init__(self, line, col, i):
        super().__init__(line, col)
        self.i = i

class Ptr_Type_Node(Node):
    def __init__(self, line, col, pointee):
        super().__init__(line, col)
        self.pointee = pointee

class Addr_Of_Node(Node):
    def __init__(self, line, col, pointee):
        super().__init__(line, col)
        self.pointee = pointee

class Proc_Type_Node(Node):
    def __init__(self, line, col, proc_params, return_type):
        super().__init__(line, col)
        self.proc_params = proc_params
        self.return_type = return_type

class Start_Node(Node):
    def __init__(self, line, col, statements):
        super().__init__(line, col)
        self.statements = statements

class Ast_Builder(lark.Transformer):
    def IDENTIFIER(self, item):
        return Identifier_Node(
            item.line,
            item.column,
            str(item.value)
        )

    def proc_type(self, items):
        return Proc_Type_Node(
            items[1].line,
            items[1].col,
            items[0],
            items[1]
        )

    def addr_of(self, items):
        return Addr_Of_Node(
            items[0].line,
            items[0].col,
            items[0]
        )

    def integer(self, items):
        return Integer_Node(
            items[0].line,
            items[0].column,
            int(items[0].value)
        )

    def assign(self, items):
        return Assing_Node(
            items[0].line,
            items[0].col,
            items[0]
        )

    def reassignment(self, items):
        return Reassignment_Node(
            items[0].line,
            items[0].col,
            items[0],
            items[1]
        )

    def plain_type(self, items):
        return Plain_Type_Node(
            items[0].line,
            items[0].col,
            items[0]
        )

    def ptr_type(self, items):
        return Ptr_Type_Node(
            items[0].line,
            items[0].col,
            items[0]
        )

    def variable(self, items):
        modifiers = []
        for item in items:
            if isinstance(item, Modifier_Node):
                modifiers.append(item)
        name = items[len(modifiers):][0]
        type_ = items[len(modifiers)+1:][0]
        assign = items[len(modifiers)+2:][0] if len(items[len(modifiers)+2:]) > 0 else None
        return Variable_Node(
            items[0].line,
            items[0].col,
            modifiers,
            name,
            type_,
            assign
        )

    def code_block(self, items):
        if len(items) > 0:
            return Code_Block(
                items[0].line,
                items[0].col,
                items
            )
        else:
            return Code_Block(
                -1,
                -1,
                items
            )

    def proc_params_pair(self, items):
        name = items[0]
        type_ = items[1]
        return Proc_Params_Pair_Node(
            items[0].line,
            items[1].col,
            name,
            type_
        )

    def proc_params(self, items):
        return items

    def modifier(self, items):
        return Modifier_Node(
            items[0].line,
            items[0].column,
            items[0]
        )

    def proc(self, items):
        modifiers = []
        for item in items:
            if isinstance(item, Modifier_Node):
                modifiers.append(item)
        name = items[len(modifiers):][0]
        proc_params = items[len(modifiers)+1:][0]
        return_type = items[len(modifiers)+2:][0]
        code_block = items[len(modifiers)+3:][0] if len(items[len(modifiers)+3:]) > 0 else None

        return Proc_Node(
            items[0].line,
            items[0].col,
            modifiers,
            name,
            proc_params,
            return_type,
            code_block
        )

    def start(self, items):
        return Start_Node(
            items[0].line,
            items[0].col,
            items
        )

def is_void_type(t):
    return type(t).__name__ == "VoidType"

class Stack_Frame:
    def __init__(self):
        self.values = {}

class Proc:
    def __init__(self, compiler, node, llvm_func, params):
        self.compiler     = compiler
        self.node         = node
        self.llvm_func    = llvm_func
        self.params       = params
        self.returned     = False

    def prologue(self):
        prologue = self.llvm_func.append_basic_block("prologue")
        self.compiler.builder = ir.IRBuilder(prologue)

        for i, p in enumerate(self.params):
            self.compiler.stack_frames[-1].values[p[0]] = self.compiler.builder.alloca(p[1], name=p[0])
            self.compiler.builder.store(self.llvm_func.args[i], self.compiler.stack_frames[-1].values[p[0]])

    def epilogue(self):
        if not self.returned:
            if is_void_type(self.llvm_func.function_type.return_type):
                self.compiler.builder.position_at_end(self.compiler.builder.block)
                self.compiler.builder.ret_void()
            else:
                self.compiler.error(self.compiler.source_path + ":" + str(self.node.line) + ":" + str(self.node.col)
                            + ": return statement is missing for " + self.llvm_func.name + ".")

class Variable:
    def __init__(self, llvm_var):
        self.llvm_var = llvm_var

class Compiler:
    def __init__(self, source_path, ast):
        self.ok = True
        self.source_path = source_path
        self.ast = ast
        self.ast_visitors = {
            "Start_Node":            self.visit_start_node,
            "Proc_Node":             self.visit_proc_node,
            "Plain_Type_Node":       self.visit_plain_type_node,
            "Proc_Params_Pair_Node": self.visit_proc_params_pair_node,
            "Variable_Node":         self.visit_variable_node,
            "Integer_Node":          self.visit_integer_node,
            "Reassignment_Node":     self.visit_reassignment_node,
            "Ptr_Type_Node":         self.visit_ptr_type_node,
            "Addr_Of_Node":          self.visit_addr_of_node,
            "Identifier_Node":       self.visit_identifier_node,
            "Proc_Type_Node":        self.visit_proc_type_node,
        }

        self.stack_frames = []
        self.stack_frames.append(Stack_Frame())

        self.types_map = {
            "void": ir.VoidType(),
            "int":  ir.IntType(32)
        }

        pre, ext = os.path.splitext(source_path)
        self.out = pre + ".ll"
        self.module = ir.Module(self.out)
        self.module.triple = binding.get_default_triple()
        self.builder = None
        self.current_variable_type = None
        self.load_current_value = True

    def error(self, msg):
        print(msg)
        self.ok = False

    def declared(self, node):
        for m in node.modifiers:
            if m.modifier == Modifier_Types.DECLARE:
                return True
        return False
    
    def defined(self, node):
        for m in node.modifiers:
            if m.modifier == Modifier_Types.DEFINE:
                return True
        return False

    def name_available(self, name):
        for sf in self.stack_frames:
            if name in sf.values:
                return False
        return True

    def find_value(self, name):
        for sf in self.stack_frames:
            if name in sf.values:
                return sf.values[name]
        return None

    def visit_proc_type_node(self, node):
        return_type = self.visit(node.return_type)
        proc_params = [self.visit(p) for p in node.proc_params]

        return ir.FunctionType(return_type, proc_params)

    def visit_identifier_node(self, node):
        name = node.text
        v = self.find_value(name)
        if v is None:
            self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                    + ": Item " + name + " doesn't exist.")
        if self.load_current_value:
            if isinstance(v, Variable):
                return self.builder.load(v.llvm_var)
            elif isinstance(v, Proc):
                return self.builder.load(v.llvm_func)
        else:
            if isinstance(v, Variable):
                return v.llvm_var
            elif isinstance(v, Proc):
                return v.llvm_func

    def visit_addr_of_node(self, node):
        self.load_current_value = False
        pointee = self.visit(node.pointee)
        self.load_current_value = True
        return pointee

    def visit_ptr_type_node(self, node):
        t = self.visit(node.pointee)
        return t.as_pointer()

    def visit_reassignment_node(self, node):
        name = node.name.text
        v = self.find_value(name)
        
        if v is None:
            self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                    + ": Item " + name + " doesn't exist.")

        if isinstance(v, Variable):
            self.current_variable_type = v.llvm_var.type.pointee
        elif isinstance(v, Proc):
            self.current_variable_type = v.llvm_func.type
        value = self.visit(node.assign.value)
        
        self.current_variable_type = None

        if isinstance(v, Variable):
            self.builder.store(value, v.llvm_var)
        elif isinstance(v, Proc):
            self.builder.store(value, v.llvm_func)

        return None

    def visit_integer_node(self, node):
        if not isinstance(self.current_variable_type, ir.IntType):
            self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                    + ": Cannot assign non-integer value to integer-type variable.")
        return ir.Constant(self.current_variable_type, node.i)

    def visit_variable_node(self, node):
        name = node.name.text
        type_ = self.visit(node.type_)

        if not self.name_available(name):
            self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                    + ": Item " + name + " is already in scope")

        if self.declared(node) and node.assign is not None:
            self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                    + ": Use define instead of declare if you'd like to assign a value.")

        if self.defined(node) and node.assign is None:
            self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                    + ": A defined variable must have a value assigned.")

        if node.assign is not None and len(self.stack_frames) == 1:
            self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                    + ": Global variables cannot be initialized in-place.")


        if len(self.stack_frames) == 1:
            self.stack_frames[-1].values[name] = Variable(ir.GlobalVariable(self.module, type_, name))
        else:
            self.stack_frames[-1].values[name] = Variable(self.builder.alloca(type_, name=name))

        if node.assign is not None:
            self.current_variable_type = type_
            val = self.visit(node.assign.value)
            self.builder.store(val, self.stack_frames[-1].values[name].llvm_var)
            self.current_variable_type = None

        return None

    def visit_start_node(self, node):
        for statement in self.ast.statements:
                self.visit(statement)
        return None

    def visit_proc_params_pair_node(self, node):
        name = node.name.text
        type_ = self.visit(node.type_)
        return (name, type_)

    def visit_plain_type_node(self, node):
        name = node.name.text
        return self.types_map[name]

    def visit_proc_node(self, node):
        return_type = self.visit(node.return_type)
        proc_params = [self.visit(p) for p in node.proc_params]
        name = node.name.text
        
        if not self.name_available(name):
            self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                    + ": Item " + name + " is already in scope")

        if self.declared(node) and self.defined(node):
            self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                  + ": Procedure " + name + " cannot be defined and declared at the same time.")
        
        llvm_func = ir.Function(
            self.module,
            ir.FunctionType(return_type, [t[1] for t in proc_params]),
            name
        )
        self.stack_frames[-1].values[name] = Proc(self, node, llvm_func, proc_params)
        
        if self.defined(node) and node.code_block is None:
            self.error(self.source_path + ":" + str(node.line) + ":" + str(node.col)
                  + ": Procedure " + name + " is defined, but it's code block is missing.") 

        if self.defined(node):
            self.stack_frames.append(Stack_Frame())
            self.find_value(name).prologue()

            if node.code_block is not None:
                for statement in node.code_block.statements:
                    self.visit(statement)

            self.find_value(name).epilogue()
            self.stack_frames.pop()

        return None

    def visit(self, node):
        return self.ast_visitors[type(node).__name__](node)

    def compile(self):
        self.visit(self.ast)

def process_source(source_path, source):
    with open("sal.lark") as f:
        grammar = f.read()
    
    p = lark.Lark(grammar, start="start", ambiguity="explicit")
    tree = p.parse(source)
    transformed = Ast_Builder().transform(tree)
    c = Compiler(source_path, transformed)
    c.compile()
    if c.ok:
        binding.initialize()
        binding.initialize_native_target()
        binding.initialize_native_asmprinter()

        parsed = binding.parse_assembly(str(c.module))
        parsed.verify()

        target = binding.Target.from_default_triple()
        machine = target.create_target_machine()
        with binding.create_mcjit_compiler(parsed, machine) as ee:
            ee.finalize_object()
            Main_ptr = ee.get_function_address("Main")
            Main = ctypes.CFUNCTYPE(None)(Main_ptr)

            Main()

class Command:
    def __init__(self, fn, desc):
        self.fn   = fn
        self.desc = desc

def build_command(argv):
    if len(argv) == 0:
        print("Bad arguments. Help:")
        print(commands["build"].desc)
        sys.exit(1)

    file = argv.pop(0)

    # TOOD: Parse additional options

    with open(file, "r") as f:
        source = f.read()
    process_source(file, source)

def help_command(argv):
    global commands

    print("Commands:\n")
    for command in commands:
        print(commands[command].desc)

commands = {
    "build": Command(
        build_command,
        (
            f"{sys.argv[0]} build <FILE> <options>\n"
            "builds an executable from <FILE> source file\n"
        )
    ),
    "help":  Command(
        help_command,
        (
            f"{sys.argv[0]} help\n"
            "prints this help message\n"
        )
    )
}

def main():
    os.chdir(os.path.dirname(os.path.realpath(__file__)))

    argv = sys.argv

    if len(argv) < 2:
        print("No command provided")
        sys.exit(1)

    argv.pop(0)
    command = argv[0]
    if command in commands:
        argv.pop(0)
        commands[command].fn(argv)
    else:
        print(f"Unknown command '{command}'")
        sys.exit(1)

main()

